<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>B-Tree a data structures -  Postgres Internals rabbit hole.. | Department of random technical stuffs</title>
<meta name="keywords" content="">
<meta name="description" content="Another sunday night, another rabbit hole.">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/posts/btree-whats-inside-your-db/">
<link crossorigin="anonymous" href="http://localhost:1313/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/btree-whats-inside-your-db/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Department of random technical stuffs (Alt + H)">Department of random technical stuffs</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/index.xml" title="RSS">
                    <span>RSS</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      B-Tree a data structures -  Postgres Internals rabbit hole..
    </h1>
    <div class="post-description">
      Another sunday night, another rabbit hole.
    </div>
    <div class="post-meta"><span title='2025-06-29 23:02:39 +0530 IST'>June 29, 2025</span>

</div>
  </header> 
  <div class="post-content"><h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<p>B-Trees are a facinating inventions in computing. They are some special kind of binary tree. But with very concrete rules. I have watched small video and now i am in the b-tree rabbit hole. I&rsquo;ts nice last time i&rsquo;ve been in a rabbit hole like this was when i was learning about prime numbers and how they used in cryptography, well thats a blog post for another day.</p>
<p>So The btree data structure in simple terms is a tree which has multiple values in single node, and children nodes can be more than 2. In binary tree we have only 2 children nodes, but in btree we can have more than 2 children nodes.</p>
<p>In binary tree the rule is to the left of the root node we have smaller values and to the right of the root node we have larger values compared to the root node, but in the btree the childrens are on a range of values and the range is defined by the parent node.</p>
<p>The most interesting part of btree is the rules which it has, why the rules? Because we wanted a datastructure which can do fast search, insert and delete operations. And the btree is designed to do that. To achieve this there are certain rules which is present in btree.</p>
<h3 id="lets-start-with-the-below-binary-tree">Lets start with the below binary tree.<a hidden class="anchor" aria-hidden="true" href="#lets-start-with-the-below-binary-tree">#</a></h3>
<pre><code>                       19
                    /    \
                  7       37
                /   \     /   \
              3     13  29    43
             / \   / \  / \   /  \
            2   5 11 17 23 31 41  47    
</code></pre>
<p>Just think about the searching in this tree, at any given point we always search on half of this tree. Either left side or right side. So the time complexity is logermic. So at this point we may feel this is really good, but think about this you have a massive amout of indexes and page poiters to eb stored in case of postgresql or mysql. And if it was binary tree then the depth of the tree will be more and more. So the search will take more time, becase even if we are searching on half of the tree, the depth of the tree is more.</p>
<p>So B trees will help us to reduce the depth of the tree, and it helps to reach the index faster. Lets see the above tree how is it represented as a btree.</p>
<p>So imagine this - Instead of spliting into half, like left child and right child, can we split into 3 and reduce the search space into 1/3, what if we split into 4 we reduce the search space to 1/4..so on. Something like below:</p>
<pre tabindex="0"><code>                    [13, 29]
                  /     |     \
        [5, 7]     [17, 23]     [37, 43]
       /     \       |       /    |     \
   [2, 3]   [11]    [19]   [31]  [41]   [47]    
</code></pre><ol>
<li>Values less than the first key of the root node will be to the left</li>
<li>Values greater than the second key of the root node will be to the right.</li>
<li>And, the values which are between first and second key will be on the middle.</li>
</ol>
<p>This is how it is represented. Now we need to look at less number of nodes to get to the answer. Now we may think there are way too many comparisons than binary tree, but imagine this. The most time spent is not on comparing but while fetching the data to be compared. In case of databases it is completely true.</p>
<h2 id="rules">Rules:<a hidden class="anchor" aria-hidden="true" href="#rules">#</a></h2>
<p>Certain rules which needs to keep in mind are.</p>
<ol>
<li>B-Tree is a balanced tree, which means all leaf nodes are at the same level.</li>
<li>Each node can have a variable number of keys and children.</li>
<li>The keys in each node are sorted in ascending order.</li>
<li>The number of keys in a node is between a predefined minimum and maximum.</li>
<li>The root node must have at least one key.</li>
</ol>
<p>So the Primary logic of B-Tree is to keep this rules intact while performing insert and delete operations.</p>
<h2 id="insert">Insert?<a hidden class="anchor" aria-hidden="true" href="#insert">#</a></h2>
<p>For example while inserting a new key if the node is full then we need to split the node into two nodes and promote the middle key to the parent node. This will keep the tree balanced and maintain the properties of B-Tree. Look at the below.</p>
<p>In our case,</p>
<p>Maximum number of keys are going to be 4.
And minimum number of keys are going to be 2.</p>
<p>We insert, 7, 23, 59 and 97. Now the first node is creted as below.</p>
<pre tabindex="0"><code>[7, 23, 59, 97]
</code></pre><p>Now the node is full, so what happens when we add the 5th key?</p>
<p>Say we are adding 73. Now the node will be splitted into two .</p>
<pre tabindex="0"><code>        [59]
       /     \
[7, 23]     [73, 97]
</code></pre><p>Now we splitted the node into two, also we promoted 59 to the parent node. Now this started looking like a simple tree.</p>
<p>Now we can add more keys to the tree.</p>
<pre tabindex="0"><code>        [59]
       /     \
[7, 19, 23]     [61, 67, 73, 79, 97]
</code></pre><p>The insertion is very smooth only problem we have is when we reach the maximum number of keys in a node. We have to split the node and promote the middle key to the parent node.
So after inserting 61 it will look like this.</p>
<pre tabindex="0"><code>        [59, 73]
       /     |     \
[7, 19, 23] [61,67] [79, 97]
</code></pre><p>So what happens the parent is full? The algorithm is recursive so it splits the parent as well and promotes and cretes a new parent node.</p>
<h1 id="delete">Delete?<a hidden class="anchor" aria-hidden="true" href="#delete">#</a></h1>
<p>Do a search as usual, find the node and delete.. So simple Not really. Becase we need to keep the properties of B-Tree intact. So we need to do some extra work while deleting a node.</p>
<p>It is possible we ended up having a node with less than minimum number of keys. So we need to merge the node with its sibling or borrow a key from its sibling. So lets delete 61</p>
<pre tabindex="0"><code>        [59, 73]
       /     |     \
[7, 19, 23] [61,67] [79, 97]
</code></pre><p>What happens in this case, we detect violation of the rules. What to do now, borrow one from sibling.<br>
Left sibling: [7, 19, 23] (has 3 keys)
Borrow 23 from left sibling
Promote 59 (from root) into current node
Replace 59 in root with 23</p>
<pre tabindex="0"><code>           [23, 73]
         /     |     \
[7, 19] [59, 67] [79, 97]
</code></pre><p>So we promoted and swapped the keys to maintain the properties of B-Tree. And this happens recursively until we reach the root node.</p>
<p>So next time somthing screed up in your database index and the writes are slow, just remember the btree and how it works. It is a very simple data structure but it has a lot of rules to maintain the properties of the tree.</p>
<p>In postgres the btree is implemented as a balanced tree with a variable number of keys and children. The implementation is done in C and it is highly optimized for performance.</p>
<h1 id="some-postgres-insights">Some postgres insights.<a hidden class="anchor" aria-hidden="true" href="#some-postgres-insights">#</a></h1>
<p>TBH I am not a great engineer, but as far as i digged.</p>
<p><a href="https://github.com/postgres/postgres/blob/master/src/backend/access/nbtree/README">https://github.com/postgres/postgres/blob/master/src/backend/access/nbtree/README</a></p>
<p>Postgres uses a slightly different implementation of B-Tree called &ldquo;B-Tree with variable-length keys&rdquo;.  And it is optimized for high concurrency and performance. If you look at the read me they say B-Tree managment algorith. But on a high level this is how it works. This is what i understood from chatgpt.</p>
<p>What is stored in the B-tree is a set of key-value pairs, where the keys are the indexed columns and the values are the corresponding row identifiers (TIDs). The B-tree is used to quickly locate the rows that match a given key value.</p>
<p>So the node will look like this.</p>
<pre tabindex="0"><code>Node (Page 10):
[
  (42, child_page=105),
  (85, child_page=109)
]
</code></pre><p>Where ctid is the tuple identifier which is used to locate the row in the table. So when you do a select query with a primary key, postgres will use the btree index to quickly locate the row in the table. So if the key is less than 42 go to the left child page, if greater than 85 go to the right child page, and if it is between 42 and 85 go to the middle child page.</p>
<p>So the next big question can i actually see this btree in action? The answer is yes. So lets start:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>docker run --name pg-btree <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -e POSTGRES_PASSWORD<span style="color:#f92672">=</span>secret <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -e POSTGRES_USER<span style="color:#f92672">=</span>justin <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -e POSTGRES_DB<span style="color:#f92672">=</span>btree_demo <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -p 5432:5432 <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>  -d postgres:15
</span></span></code></pre></div><p>Pull it down and run it. :p</p>
<p>Now connecto to it and run the below commands.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> demo (id INT <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> demo <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">10</span>), (<span style="color:#ae81ff">42</span>), (<span style="color:#ae81ff">85</span>);
</span></span></code></pre></div><p>Once you do this you can see the btree index created for the primary key.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>btree_demo<span style="color:#f92672">=#</span> <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> bt_page_items(get_raw_page(<span style="color:#e6db74">&#39;demo_pkey&#39;</span>, <span style="color:#ae81ff">1</span>));
</span></span></code></pre></div><pre tabindex="0"><code> itemoffset | ctid  | itemlen | nulls | vars |          data           | dead | htid  | tids
------------+-------+---------+-------+------+-------------------------+------+-------+------
          1 | (0,1) |      16 | f     | f    | 0a 00 00 00 00 00 00 00 | f    | (0,1) |
          2 | (0,2) |      16 | f     | f    | 2a 00 00 00 00 00 00 00 | f    | (0,2) |
          3 | (0,3) |      16 | f     | f    | 55 00 00 00 00 00 00 00 | f    | (0,3) |
</code></pre><p>So the data is stored as hex values, if you convert it to decimal its basically the id values. So the first item is 10, second item is 42 and third item is 85.</p>
<p>So our node will be like this.</p>
<pre tabindex="0"><code>Leaf Node (Page 1):
[
  (10 → TID(0,1)),
  (42 → TID(0,2)),
  (85 → TID(0,3))
]
</code></pre><p>So if i do a select query with id 42, postgres will use the btree index to quickly locate the row in the table.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> demo <span style="color:#66d9ef">WHERE</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>;
</span></span></code></pre></div><p>It essentially does a binary search and finds outs its htid, htid means heap tuple identifier which is used to locate the row in the table.
In our case our tupe is on page 0 and tuple 2. So it will go to the page 0 and fetch the tuple 2.(that is our row with id 42)</p>
<p>The end! I will try to dig more into its source code and to try to undestand how it works for sure. This is just a high level overviiew.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer><script src="https://giscus.app/client.js"
        data-repo="mathewjustin/justinmathew"
        data-repo-id="R_kgDOOVcB9A"
        data-category="General"
        data-category-id="DIC_kwDOOVcB9M4Co3QS"
        data-mapping="pathname"
        data-strict="0"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="preferred_color_scheme"
        data-lang="en"
        crossorigin="anonymous"
        async>
</script>


</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Department of random technical stuffs</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
