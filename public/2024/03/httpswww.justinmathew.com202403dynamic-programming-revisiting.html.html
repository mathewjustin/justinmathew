<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Revisiting Dynamic Programming | Department of random technical stuffs</title>
<meta name="keywords" content="DynamicProgramming, Data Structures">
<meta name="description" content="

The main problem with me w.r.t DP problem is forgetting it if i don&#39;t 

practice. So I decided to revisit all the DP problems i solved once again 

just to refresh my memory.

  
So first Lets start with a simple one. Here we go!!!  
  
Climbing stairs from Leetcode.  
  

Explanation : You are climbing a staircase. 

It takes n steps to reach the top.  
Each time you can either climb 1 or 2 steps. In how many 

distinct ways can you climb to the top?

Example 1:  
  
Input: n = 2  
Output: 2  
Explanation: There are two ways to climb to the top.  
1\. 1 step &#43; 1 step  
2\. 2 steps  
  
Example 2:  
Input: n = 3  
Output: 3  
Explanation: There are three ways to climb to the top.  
  
1\. 1 step &#43; 1 step &#43; 1 step  
2\. 1 step &#43; 2 steps  
3\. 2 steps &#43; 1 step  
  
So how can we solve this simple problem?  
  
As usual we can solve this problem using recursion.   
But the problem with recursion is it will have exponential time complexity.   
In recursive way the following is the solution     \`\`\`java  
 public int climbStairs(int n) { if(n == 1) return 1; if(n == 2) return 2; return climbStairs(n-1) &#43; climbStairs(n-2); } \`\`\`  
The logic of the above is : 

 \* If n is 1 then there is only one way to climb the stair. \* If n is 2 then there are two ways to climb the stair. \* If n is greater than 2 then the number of ways to climb the stair is  the sum of the number of ways to climb the stair when n-1 and n-2.
So we recursively call climbStairs(n-1) and climbStairs(n-2) and">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/2024/03/httpswww.justinmathew.com202403dynamic-programming-revisiting.html.html">
<link crossorigin="anonymous" href="/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/2024/03/httpswww.justinmathew.com202403dynamic-programming-revisiting.html.html">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Department of random technical stuffs (Alt + H)">Department of random technical stuffs</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Revisiting Dynamic Programming
    </h1>
    <div class="post-meta"><span title='2024-03-19 13:11:00 -0700 -0700'>March 19, 2024</span>

</div>
  </header> 
  <div class="post-content"><pre tabindex="0"><code>

The main problem with me w.r.t DP problem is forgetting it if i don&#39;t 

practice. So I decided to revisit all the DP problems i solved once again 

just to refresh my memory.

  
So first Lets start with a simple one. Here we go!!!  
  
Climbing stairs from Leetcode.  
  

Explanation : You are climbing a staircase. 

It takes n steps to reach the top.  
Each time you can either climb 1 or 2 steps. In how many 

distinct ways can you climb to the top?

Example 1:  
  
Input: n = 2  
Output: 2  
Explanation: There are two ways to climb to the top.  
1\. 1 step + 1 step  
2\. 2 steps  
  
Example 2:  
Input: n = 3  
Output: 3  
Explanation: There are three ways to climb to the top.  
  
1\. 1 step + 1 step + 1 step  
2\. 1 step + 2 steps  
3\. 2 steps + 1 step  
  
So how can we solve this simple problem?  
  
As usual we can solve this problem using recursion.   
But the problem with recursion is it will have exponential time complexity.   
In recursive way the following is the solution     \`\`\`java  
 public int climbStairs(int n) { if(n == 1) return 1; if(n == 2) return 2; return climbStairs(n-1) + climbStairs(n-2); } \`\`\`  
The logic of the above is : 

 \* If n is 1 then there is only one way to climb the stair. \* If n is 2 then there are two ways to climb the stair. \* If n is greater than 2 then the number of ways to climb the stair is  the sum of the number of ways to climb the stair when n-1 and n-2.
</code></pre><p>So we recursively call climbStairs(n-1) and climbStairs(n-2) and</p>
<pre tabindex="0"><code>add them to get the result.  
What is the problem with this approach?  
  
The problem with this approach is it has exponential time complexity.  
For example if n = 5 then the number of ways to climb the stair is 8.  
So the number of recursive calls will be 8.  
If n = 6 then the number of ways to climb the stair is 13.  
So the number of recursive calls will be 13.  
if n=7 then the number of ways to climb the stair is 21.  
So the number of recursive calls will be 21.  
So the time complexity of this approach is O(2^n). 
</code></pre><p>Where n is the number of stairs. and 2 is the number of ways to</p>
<pre tabindex="0"><code>climb the stair.  
  
If we construct a recursion tree for n=5 it will look like below.  
  
!\[\](img\_1.png)  
  
Space complexity of this approach is O(n) where n is the number of stairs.  
Or in other words the depth of the recursion tree is n.  
  
So lets get into the basic dynamic programming approach.  
  
\`\`\`java  
class Solution {  
 // A function that represents the answer to the problem for a given state private int dp(int i) { if (i &lt;= 2) return i; // Base cases return dp(i - 1) + dp(i - 2); // Recurrence relation }     public int climbStairs(int n) {  
 return dp(n); }}  
\`\`\`  
  
The above approach is a top-down approach. Means we are solving the problem 
</code></pre><p>from the top to the bottom. The time complexity of the above approach is</p>
<pre tabindex="0"><code>O(2^n) and the space complexity is O(n). 
</code></pre><pre tabindex="0"><code>**_So this is not really dynamic programming._** 
</code></pre><pre tabindex="0"><code>This is just a recursive approach. So lets get into the bottom-up approach.
</code></pre><p>```java<br>
class Solution {<br>
public int climbStairs(int n) { if (n &lt;= 2) return n; // Base cases int[] dp = new int[n + 1]; // Create an array to store</p>
<pre tabindex="0"><code>// the subproblems  
 dp\[1\] = 1; // Base case dp\[2\] = 2; // Base case for (int i = 3; i &lt;= n; i++) { dp\[i\] = dp\[i - 1\] + dp\[i - 2\]; // The recurrence relation } return dp\[n\]; // The answer to the problem for n steps }}  
\`\`\`  
  
The above approach is a bottom-up approach. Means we are solving the problem 
</code></pre><p>from the bottom to the top. Also the above approach is a tabulation approach.</p>
<pre tabindex="0"><code>Means we are solving the problem using an array to store the subproblems. 
</code></pre><p>The time complexity of the above approach is O(n) and the space</p>
<pre tabindex="0"><code>complexity is O(n). The flow goes like this : 
</code></pre><p>* dp[1] = 1 // Base case Means if there is only one stair then</p>
<p>there is only one way to climb the stair.<br>
* dp[2] =  2 // Base case Means if there are two stairs then</p>
<p>there are two ways to climb the stair.</p>
<p>from 3 to n we calculate the number of ways to climb the stair</p>
<p>using the following formula.</p>
<pre tabindex="0"><code>\* dp\[i\] \=  dp\[i - 1\] \+ dp\[i - 2\] // The recurrence relation  
\* dp\[n\] // The answer to the problem for n steps  
  
So if you look at the first example of recursive approach the number 
</code></pre><p>of recursive calls for n=5 is 8. But if you look at the bottom-up</p>
<pre tabindex="0"><code>approach the number of steps to calculate the number of ways to climb the 
</code></pre><p>stair for n=5 is 5. So the time complexity of the bottom-up approach is O(n)</p>
<pre tabindex="0"><code>and the space complexity is O(n).
</code></pre><p>So lets get into another problem. This is a Medium one.<br>
And this is a classic one.</p>
<p>The problem is House Robber from Leetcode.</p>
<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that</p>
<p>adjacent houses have security systems connected and it will</p>
<p>automatically contact the police if two adjacent houses were broken into on</p>
<p>the same night.</p>
<pre tabindex="0"><code>  

Base case : If there is 4 houses then the maximum amount of money you can rob is the maximum of the amount of money in the first house and   
the amount of money in the second house. plus the maximum amount of money you can rob from the remaining houses.
</code></pre><p>The intuition behind the problem is the following.</p>
<p>maxRobbedAmount[0]=nums[0]<br>
maxRobbedAmount[1]=max(maxRobbedAmount[0],nums[1])<br>
maxRobbedAmount[2]=max(maxRobbedAmount[0]+nums[2],maxRobbedAmount[1])<br>
maxRobbedAmount[3]=max(maxRobbedAmount[1]+nums[3],maxRobbedAmount[2])<br>
maxRobbedAmount[4]=max(maxRobbedAmount[2]+nums[4],maxRobbedAmount[3])</p>
<p>Equation : maxRobbedAmount[i]=max(maxRobbedAmount[i-2]+nums[i],</p>
<pre tabindex="0"><code> maxRobbedAmount\[i-1\])  
  
So the solution is the following.  
  
\`\`\`java  

class Solution {  
 public int rob(int\[\] nums) { if (nums.length == 0) return 0; if (nums.length == 1) return nums\[0\]; if (nums.length == 2) return Math.max(nums\[0\], nums\[1\]); int\[\] maxRobbedAmount = new int\[nums.length\]; maxRobbedAmount\[0\] = nums\[0\]; maxRobbedAmount\[1\] = Math.max(nums\[0\], nums\[1\]); for (int i = 2; i &lt; nums.length; i++) { maxRobbedAmount\[i\] = Math.max(maxRobbedAmount\[i - 2\] + nums\[i\], maxRobbedAmount\[i - 1\]);  
 } return maxRobbedAmount\[nums.length - 1\]; }}
</code></pre><p>```</p>
<p>The above approach is a bottom-up approach. Means we are solving the</p>
<p>problem from the bottom to the top. Also the above approach is a</p>
<p>tabulation approach. Means we are solving the problem using an array to</p>
<p>store the subproblems.So the time complexity of the above approach is O(n)</p>
<p>and the space complexity is O(n). Because we are using an array to store</p>
<p>the subproblems.</p>
<pre tabindex="0"><code>  

```
</code></pre>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/dynamicprogramming/">DynamicProgramming</a></li>
      <li><a href="http://localhost:1313/tags/data-structures/">Data Structures</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Department of random technical stuffs</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
