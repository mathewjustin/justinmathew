<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Data Structures on Department of random technical stuffs</title>
    <link>http://localhost:1313/tags/data-structures/</link>
    <description>Recent content in Data Structures on Department of random technical stuffs</description>
    <generator>Hugo -- 0.145.0</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 19 Mar 2024 13:11:00 -0700</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/data-structures/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Revisiting Dynamic Programming</title>
      <link>http://localhost:1313/2024/03/httpswww.justinmathew.com202403dynamic-programming-revisiting.html.html</link>
      <pubDate>Tue, 19 Mar 2024 13:11:00 -0700</pubDate>
      <guid>http://localhost:1313/2024/03/httpswww.justinmathew.com202403dynamic-programming-revisiting.html.html</guid>
      <description>&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;

The main problem with me w.r.t DP problem is forgetting it if i don&amp;#39;t 

practice. So I decided to revisit all the DP problems i solved once again 

just to refresh my memory.

  
So first Lets start with a simple one. Here we go!!!  
  
Climbing stairs from Leetcode.  
  

Explanation : You are climbing a staircase. 

It takes n steps to reach the top.  
Each time you can either climb 1 or 2 steps. In how many 

distinct ways can you climb to the top?

Example 1:  
  
Input: n = 2  
Output: 2  
Explanation: There are two ways to climb to the top.  
1\. 1 step + 1 step  
2\. 2 steps  
  
Example 2:  
Input: n = 3  
Output: 3  
Explanation: There are three ways to climb to the top.  
  
1\. 1 step + 1 step + 1 step  
2\. 1 step + 2 steps  
3\. 2 steps + 1 step  
  
So how can we solve this simple problem?  
  
As usual we can solve this problem using recursion.   
But the problem with recursion is it will have exponential time complexity.   
In recursive way the following is the solution     \`\`\`java  
 public int climbStairs(int n) { if(n == 1) return 1; if(n == 2) return 2; return climbStairs(n-1) + climbStairs(n-2); } \`\`\`  
The logic of the above is : 

 \* If n is 1 then there is only one way to climb the stair. \* If n is 2 then there are two ways to climb the stair. \* If n is greater than 2 then the number of ways to climb the stair is  the sum of the number of ways to climb the stair when n-1 and n-2.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So we recursively call climbStairs(n-1) and climbStairs(n-2) and&lt;/p&gt;</description>
    </item>
    <item>
      <title>Algorithms and Data Structures on Python - Notes 2</title>
      <link>http://localhost:1313/posts/algorithms-and-data-structures-on-python-notes-2/</link>
      <pubDate>Wed, 30 Sep 2020 10:57:00 -0700</pubDate>
      <guid>http://localhost:1313/posts/algorithms-and-data-structures-on-python-notes-2/</guid>
      <description>&lt;p&gt;** Linked list**&lt;/p&gt;
&lt;p&gt;It needs a node class&lt;/p&gt;
&lt;p&gt;It should have 2 basic characteristic&lt;/p&gt;
&lt;p&gt;* Data&lt;/p&gt;
&lt;p&gt;* Reference to the next node&lt;/p&gt;
&lt;p&gt;It can be used to implement stack or queues. It does not allow random access as like in Array.&lt;/p&gt;
&lt;p&gt;Obtaining a last node, locating a particular node requires an iteration over all or most of the items in the linked list. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Advantage&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;* It is dynamic data structures(No need to specify size)&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
